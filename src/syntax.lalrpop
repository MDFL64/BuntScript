use std::str::FromStr;
use crate::front::ParserState;
use crate::middle::{Function,ExprKind,BinOp,Symbol,Type,Stmt,ExprHandle};

grammar(state: &mut ParserState);

Empty = ();

List<T>: Vec<T> = {
    Empty => vec!(),
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
}

// <ret_ty: (":" <Type>)?>
pub Function: Function = "function" <name:Symbol> "(" <args:List<Arg>> ")" <e:Block> => {
    let exprs = std::mem::take(&mut state.exprs);
    Function::new(args,exprs,e)
};

Arg: (Symbol,Type) = <s:Symbol> ":" <t:Type> => (s,t);

Type: Type = {
    "number" => Type::Number,
    "boolean" => Type::Bool,
    "void" => Type::Void,
}

Block: ExprHandle = "{" <stmts:(<Stmt> ";")*> <result:Expr?> "}" => {
    state.alloc_expr(ExprKind::Block{
        stmts,
        result
    })
};

Stmt: Stmt = {
    "let" <name:Symbol> <ty: (":" <Type>)?> <init: ("=" <Expr>)?> => Stmt::new_let(name,None,init),
    <e:Expr> => Stmt::Expr(e),
}

Term: ExprHandle = {
    <n:Num> => state.alloc_expr(ExprKind::Number(n)),
    <s:Symbol> => state.alloc_expr(ExprKind::Ident(s)),
    "(" <Expr> ")",
    If,
    While
}

Expr: ExprHandle = {
    #[precedence(level="0")]
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Mul,r)),
    <l:Expr> "/" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Div,r)),
    <l:Expr> "%" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Mod,r)),

    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Add,r)),
    <l:Expr> "-" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Sub,r)),

    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "<" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Lt,r)),
    <l:Expr> ">" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::Gt,r)),
    <l:Expr> "<=" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::LtEq,r)),
    <l:Expr> ">=" <r:Expr> => state.alloc_expr(ExprKind::Binary(l,BinOp::GtEq,r)),

    #[precedence(level="5")] #[assoc(side="right")]
    <l:Expr> "=" <r:Expr> => state.alloc_expr(ExprKind::Assign(l,r)),

    #[precedence(level="9")]
    "return" <e:Expr> => state.alloc_expr(ExprKind::Return(Some(e))),
};

If: ExprHandle = {
    "if" <c:Expr> <t:Block> "else" <f:Block> => state.alloc_expr(ExprKind::If(c,t,Some(f)))
}

While: ExprHandle = {
    "while" <c:Expr> <b:Block> => state.alloc_expr(ExprKind::While(c,b))
}

Num: f64 = <s:r"[0-9]+"> => f64::from_str(s).unwrap();

Symbol: Symbol = <s:r"[_A-Za-z][_A-Za-z0-9]*"> => Symbol::new(s);
